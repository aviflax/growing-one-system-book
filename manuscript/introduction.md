# Introduction

Let's build something together. In fact, let's build a real system running in production, with users and all. We will do it incrementally, in the cloud, with continuous delivery. And the whole process will be written down to show the twists, turns, and dead ends. Finally, just to make it even more visible and (potentially) embarrassing, let's put that historical record online incrementally too.

## About this Book

This book may be a bit peculiar. It's not going to be about general programming principles and practices. At least, not directly. Neither will it be be about an idealization on a whiteboard or Visio diagram. Those books have their places and they provide value for many people. But I'm also conscious that humans vary, and that includes their learning styles. Some people like to go from general to specific. They are happy to begin with principles first and treat specific systems as derivations of those principles. This is the home of deductive reasoning. Other people prefer to start with instances and examples, then apply inductive reasoning to find the general principles. In my previous book "[Release It!](https://pragprog.com/book/mnee2/release-it-second-edition)" I kept those learning styles in mind when I alternated between case studies (appealing to induction) and patterns (made for deduction.)

I want to write this book as I build a specific system. I'm inspired here by Jesse Liberty's "Clouds to Code" which did the same thing for a C++ system in the 1990's. I admired Jesse's transparency as he worked through the book and system together. Some of the early decisions worked out well, but some of them didn't. He courageously left all of them in the book, without trying to gloss over any of the dead-ends or bad choices. Meanwhile, readers learned his thought process. I hope to achieve the same thing here: share my thought process as best I can. The "why" of a decision is much more interesting than the "what."

Two other influences on this book are the online book projects, [Crafting Interpreters](http://craftinginterpreters.com/) by Bob Nystrom and [Writing an OS in Rust](https://os.phil-opp.com/) by Phil Opperman. Each of these in currently being published one chapter at a time, with every line of code shown. Bob and Phil are both excellent writers and I've enjoyed following these projects and coding along one installment at a time. Somehow, even the wait between chapters makes me appreciate each new piece more. Binge-watching may be good for entertainment but probably not so much for knowledge retention. Every time a new chapter comes out, I need to review the previous work, so it naturally creates a periodic reinforcement.

One place where this project differs from Bob and Phil is that they both have clear roadmaps. Their goal is to teach, with the project as a vehicle for that teaching. They've also each done enough design to know where they are going. I'm going out on a limb a bit here by including the design in the book itself. A typical installment will have some retrospective, architecture, design, coding, and operations work. That means I will make mistakes, some serious and some risible. Feedback welcome. "Pull requests welcome" as they say. And I mean that in the encouraging way, not the "code or GTFO" way!

Finally, a third factor. Putting this out in the open will apply some pressure to keep going and _finish_ the thing. My virtual workshop holds dozens of half-baked projects. It's a good thing they don't take up space in my house. (Nevermind that partially assembled RepRap over there. Or that stack of Raspberry Pis that will be put to good use _any day now_.) A deadline does wonders for my focus. An audience, even more so!

When Jesse wrote "Clouds to Code," LeanPub did not exist. GitHub didn't exist. In fact, Git itself probably didn't exist. "Agile" was still called "lightweight methods" and "the cloud" was what telephone company sales execs drew when they just didn't know where the call center was physically located. Today, we do things very differently. Incremental development and feedback help a project stay on track.

I hope you will find the process interesting rather than self-indulgent. Feel free to tweet at me ([@mtnygard](https://twitter.com/mtnygard)) or post an issue on Github. If, by some chance, you also find the system itself interesting, I would be delighted to hear about that too. Since my target user is mainly just me, I expect focus group testing to be pretty easy to arrange. On the other hand, myopia can set in quickly. Let me know where you see problems, edge cases, or howlers in the design. Please head to the [project repository](https://github.com/mtnygard/cloudseeding) and report an issue. You just might get incorporated into the next chapter!

## My Commitments to You

Dear reader, I commit to be open and intellectually honest in this process. I will not erase mistakes from the record, nor from previous chapters. Dead ends will remain dead ends. I will assume that your feedback and criticism comes from a place of generous contribution and positive intent. I may revise the prose of previous chapters, especially where your feedback tells me that I've skipped something in technical presentation. I may improve the clarity or sharpen the text to make it more useful to the next reader.

With that, let's explore the problem space in the next chapter.
