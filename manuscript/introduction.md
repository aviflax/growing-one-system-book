# Introduction

Let's build something together. In fact, let's build a real system running in production, with users and all. We will do it incrementally, in the cloud, with continuous delivery. And the whole process will be written down to show the twists, turns, and dead ends. Finally, just to make it even more visible and (potentially) embarrassing, let's put that historical record online incrementally too.

## About this Book

This book may be a bit peculiar. It's not going to be about general programming principles and practices. At least, not directly. Neither will it be be about an idealization on a whiteboard or Visio diagram. Those books have their places and they provide value for many people. But I'm also conscious that humans vary, and that includes their learning styles. Some people like to go from general to specific. They are happy to begin with principles first and treat specific systems as derivations of those principles. This is the home of deductive reasoning. Other people prefer to start with instances and examples, then apply inductive reasoning to find the general principles. In my previous book "Release It!" I kept those learning styles in mind when I alternated between case studies (appealing to induction) and patterns (made for deduction.)

I want to write this book as I build a specific system. I'm inspired here by Jesse Liberty's "Clouds to Code" which did the same thing for a C++ system in the 1990's. I admired Jesse's transparency as he worked through the book and system together. Some of the early decisions worked out well, but some of them didn't. He courageously left all of them in the book, without trying to gloss over any of the dead-ends or bad choices. Meanwhile, readers learned his thought process. I hope to achieve the same thing here: share my thought process as best I can. The "why" of a decision is much more interesting than the "what."

Two other influences on this book are the online book projects, [Crafting Interpreters](http://craftinginterpreters.com/) by Bob Nystrom and [Writing an OS in Rust](https://os.phil-opp.com/) by Phil Opperman. Each of these in currently being published one chapter at a time, with every line of code shown. Bob and Phil are both excellent writers and I've enjoyed following these projects and coding along one installment at a time. Somehow, even the wait between chapters makes me appreciate each new piece more. Binge-watching may be good for entertainment but probably not so much for knowledge retention. Every time a new chapter comes out, I need to review the previous work, so it naturally creates a periodic reinforcement.

One place where this project differs from Bob and Phil is that they both have clear roadmaps. Their goal is to teach, with the project as a vehicle for that teaching. They've also each done enough design to know where they are going. I'm going out on a limb a bit here by including the design in the book itself. A typical installment will have some retrospective, architecture, design, coding, and operations work. That means I will make mistakes, some serious and some risible. Feedback welcome. "Pull requests welcome" as they say. And I mean that in the encouraging way, not the "code or GTFO" way!

Finally, a third factor. Putting this out in the open will apply some pressure to keep going and _finish_ the thing. My virtual workshop holds dozens of half-baked projects. It's a good thing they don't take up space in my house. (Nevermind that partially assembled RepRap over there. Or that stack of Raspberry Pis that will be put to good use _any day now_.) A deadline does wonders for my focus. An audience, even more so!

When Jesse wrote "Clouds to Code," LeanPub did not exist. GitHub didn't exist. In fact, Git itself probably didn't exist. "Agile" was still called "lightweight methods" and "the cloud" was what telephone company sales execs drew when they just didn't know where the call center was physically located. Today, we do things very differently. Incremental development and feedback help a project stay on track.

I hope you will find the process interesting rather than self-indulgent. Feel free to tweet at me ([@mtnygard](https://twitter.com/mtnygard)) or post an issue on Github. If, by some chance, you also find the system itself interesting, I would be delighted to hear about that too. Since my target user is mainly just me, I expect focus group testing to be pretty easy to arrange. On the other hand, myopia can set in quickly. Let me know where you see problems, edge cases, or howlers in the design. Please head to the [project repository](https://github.com/mtnygard/cloudseeding) and report an issue. You just might get incorporated into the next chapter!

## My Commitments to You

Dear reader, I commit to be open and intellectually honest in this process. I will not erase mistakes from the record, nor from previous chapters. Dead ends will remain dead ends. I will assume that your feedback and criticism comes from a place of generous contribution and positive intent. I may revise the prose of previous chapters, especially where your feedback tells me that I've skipped something in technical presentation. I may improve the clarity or sharpen the text to make it more useful to the next reader.

## About the System

Open sourcerors since ancient times advise, "scratch your own itch." Build that which is useful to you and use it. Be your own first customer. Then you know it can be used by at least one person and you understand that person's needs. That's the plan here.

One of my most common engagements is an architecture review. These days most of them also relate to breaking big rocks into smaller rocks. In simpler days, the focus might have been to reduce TCO, improve stability, break down walls between groups, or just find performance problems. Whatever the ultimate aim, there's a component of the work that remains the same. Six to ten times a year, I need to enter a new complex environment, understand the existing landscape, and find points of leverage. I will have somewhere between a day and several weeks to assimilate knowledge about the current systems in place, and I'm usually learning from people who've been immersed in it for years. We call it "knowledge transfer" which sounds very orderly, like a row of neatly organized boxes waiting to be loaded into one's cortex. Orderly it is not.

Rather than discussing every issue at the highest level of abstraction, then unpacking each one to the next level, and so on, the real work resembles a fractal. We dive deep in certain areas then surface back to the high level. I will leave "breadcrumbs" for myself to return to other areas for later exploration. We will sometimes shift gears from abstract architecture concerns to talk about authentication and authorization, or monitoring, or database schema design. We will shift from discussing the implementation style of a runtime component into delivery pipelines. Does it sound chaotic and disorganized? Sometimes it is!

We often have some drawings or documents to supply the top-level structure. But even when talking through these, people think of other issues, or historical details, or they want to jump ahead to their most painful problems. Meetings can be contained to agendas, people much less so.

As the receiver of the information, my task is to learn and remember. I will ask questions to clarify or understand, but I really don't like to ask the same question over and over again. As the river of information flows with its eddies and tributaries, I need to snare and organize the nuggets of information.

There's one more dimension to complicate matters. The people who provide this information may be wrong. After all, what they each share with me is their own model of the system. There are times when the key people hold incoherent beliefs about the system in question. Overlay two partially filled-in maps and they may disagree even if some landmarks align.

Ultimately, it's about integrating facts into a somewhat coherent model of the system, even when those facts arrive in fragments and may contradict each other. Most of the time I carry the model in a collection of documents, diagrams, and neurons, each with a partial, interlocking representation. Later, I interrogate that model to understand how the system-wide qualities are handled. I look for weak points, cut sets, immutable characteristics, fixed points, and points of leverage with high return.